# ApplicationEventPublisher

完整类名：`org.springframework.context.ApplicationEventPublisher`。

```java
@FunctionalInterface
public interface ApplicationEventPublisher {
    default void publishEvent(ApplicationEvent event) {
		publishEvent((Object) event);
	}
    
    void publishEvent(Object event);
}
```

该接口定义了事件发布api。

# ApplicationEventMulticaster

完整类名：`org.springframework.context.event.ApplicationEventMulticaster`。

```java
public interface ApplicationEventMulticaster {
    void addApplicationListener(ApplicationListener<?> listener);
    void addApplicationListenerBean(String listenerBeanName);
    void removeApplicationListener(ApplicationListener<?> listener);
    void removeApplicationListenerBean(String listenerBeanName);
    void removeAllListeners();
    void multicastEvent(ApplicationEvent event);
    void multicastEvent(ApplicationEvent event, @Nullable ResolvableType eventType);
}
```

该接口定义了事件监听器管理api和广播事件api。

## AbstractApplicationEventMulticaster

完整类名：`org.springframework.context.event.AbstractApplicationEventMulticaster`。

```java
public abstract class AbstractApplicationEventMulticaster
		implements ApplicationEventMulticaster, BeanClassLoaderAware, BeanFactoryAware {
    // 用于存储注册的事件处理器，也用于获取其中存储的所有的事件处理器
    private final ListenerRetriever defaultRetriever = new ListenerRetriever(false);

    // 缓存特定ApplicationEvent的的事件处理器ListenerRetriever。
	final Map<ListenerCacheKey, ListenerRetriever> retrieverCache = new ConcurrentHashMap<>(64);
    
    /**
     * 事件监听器缓存键
     */
    private static final class ListenerCacheKey implements Comparable<ListenerCacheKey> {
        
        // 事件类型
        private final ResolvableType eventType;

        // 事件来源类型
		@Nullable
		private final Class<?> sourceType;
    }
    
}
```

- 该抽象基类实现了所有与事件监听器管理相关的api。
- 提供了获取全部事件监听器/获取特定事件类型和来源的事件监听器api。

## SimpleApplicationEventMulticaster

完整类名：`org.springframework.context.event.SimpleApplicationEventMulticaster`。

```java
public class SimpleApplicationEventMulticaster extends AbstractApplicationEventMulticaster {
    @Nullable
	private Executor taskExecutor;
    @Nullable
	private ErrorHandler errorHandler;
    
    @Override
	public void multicastEvent(final ApplicationEvent event, @Nullable ResolvableType eventType) {
		ResolvableType type = (eventType != null ? eventType : resolveDefaultEventType(event));
		Executor executor = getTaskExecutor();
		for (ApplicationListener<?> listener : getApplicationListeners(event, type)) {
            // 如果存在Executor，事件监听器的处理逻辑则在单独线程中执行
			if (executor != null) {
				executor.execute(() -> invokeListener(listener, event));
			}
            // 否则事件监听器的处理逻辑则在当前线程中执行
			else {
				invokeListener(listener, event);
			}
		}
	}
    
    protected void invokeListener(ApplicationListener<?> listener, ApplicationEvent event) {
		ErrorHandler errorHandler = getErrorHandler();
        // 如果存在EventHandler，则会将事件监听器的处理逻辑中的所有异常都转发给它去处理
		if (errorHandler != null) {
			try {
				doInvokeListener(listener, event);
			}
			catch (Throwable err) {
				errorHandler.handleError(err);
			}
		}
		else {
			doInvokeListener(listener, event);
		}
	}
}
```