# 字符 char

Java中的char类型是16位的，描述了UTF-16编码中的一个代码单元。

`码点`(code point) 是指与一个编码表中的某个字符对应的代码值。

`UTF-16` 编码采用不同长度的编码表示所有的 `Unicode` 码点。

- 在基本多语音平面中，每个字符用16位表示，通常称为代码单元。
- 辅助字符编码为一对连续的代码单元。采用这种编码对表示的各个值落入基本多语音平面中未用的2048个值范围内，通常称为替代区域。
  - U+D800 ~ U+DBFF 用于第一个代码单元。
  - U+DC00 ~ U+DFFF 用于第二个代码单元。

这样设计十分巧妙，可以从中迅速知道一个代码单元是一个字符的编码，还是一个辅助字符的第一或第二部分。

`Character` 提供了一些方法来判断代码单元的类型。

# 字符串

Java 中的字符串是不可变的，无法替换其中的某个字符。

- 只能通过创建新的字符串的方式来完成某个字符的替换，效率确实不高。
- 但是编译器可以让字符串共享，提高了效率。
  - 实际上只有字符串字面量是共享的，通过+或substring等操作得到的字符串并不共享。

## 代码单元与码点

长度：

- String#length：返回UTF-16编码表示给定字符串所需要的代码单元数量。
- String#codePointCount：返回码点数量。

指定位置

```java
String greeting = "Hello";
// String#charAt 返回指定位置的代码单元
char first = greeting.charAt(0);
// String#codePointAt 返回指定位置的码点
int index = greeting.offsetByCodePoints(0, i);
int cp = greeting.codePointAt(index);
// 获取字符串的所有码点
int[] codePoints = greeting.codePoints().toArray();
```



# 浮点数 

## 运算

对于浮点数的算术运算，实现可移植性是相当困难的。double 类型使用 64 位存储一个数值，而有些处理器则使用80位浮点寄存器。这些寄存器增加了中间过程的计算精度。

- 这样可以得到一个更加精确的计算结果，并且还能够避免产生指数溢出。
- 但是，这个结果可能与始终使用64位计算的结果不一致。

Java 的应对方案

- 默认情况下，现在虚拟机设计者允许对中间计算结果采用扩展的精度，以提高精度和计算效率。
- 同时提供了 `strictfp` 关键字来标记方法或类来指定某个方法或某个类中的所有方法必须使用严格的浮点计算来生成可再生的结果。

## Math

Math

- Math 提供了大部分常用的数学运算，为了达到最佳的性能，所有的方法都使用计算机浮点单元中的例程。
- Math 类提供了一些方法使整数有更好的运算安全性，计算溢出会抛出异常。如：`addExact` 。

StrictMath

- StrictMath 实现了“可自由分发的数学库”，可以得到一个完全可预测的结果，但是运行速度相对慢一些。