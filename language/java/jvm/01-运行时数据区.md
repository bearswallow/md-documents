# 运行时数据区域

![Java虚拟机运行时数据区](E:\git-local\own\md-documents\language\java\jvm\assets\Java虚拟机运行时数据区.png)

## 线程隔离数据区

线程隔离数据区逻辑上包含：程序计数器、虚拟机栈 和 本地方法栈。

### 程序计数器

程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选择下一条需要执行的字节码指令。

如果线程正在执行的是 `Native` 方法，这个计数器值则为空。

### `Java` 虚拟机栈

虚拟机栈描述的是 `Java` 方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（`Stack Frame`）用于存储局部变量表（即：本地变量表）、操作数栈、动态链接、方法出口等信息。

每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。

![Java虚拟机栈](E:\git-local\own\md-documents\language\java\jvm\assets\Java虚拟机栈.png)

局部变量表所需的内存空间在编译期间已经完全确定，在方法运行期间不会改变局部变量表的大小。

### 本地方法栈

它与虚拟机栈所发挥的作用是非常相似的，只是在调用 `Native` 方法时使用。`Sun HotSpot VM` 将它与虚拟机栈合二为一了。

## 共享数据区

### `Java` 堆

`Java` 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。它用于存放对象实例，几乎所有的对象实例都在这里分配内存（除了 `JIT` 编译器和逃逸技术等产生的栈上分配、标量替换等优化技术）。

`Java` 堆是垃圾收集器管理的主要区域。现在收集器基本都采用分代收集算法，所以 `Java` 堆中还会进行细分，但进一步划分的目的是为了更好地回收内存，或者更快地分配内存。

`Java` 堆中的数据也是并发编程需要安全处理的数据。

### 方法区

它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

这区域的内存回收目标主要是针对常量池的回收和对类型的卸载。

**运行时常量池** 是方法区的一部分，包含 `Class` 文件中的常量池和运行期生成的新的常量（主要是字符串）。

## 直接内存

直接内存（`Direct Memory`）并不是虚拟机运行时数据区的一部分，它并不会受到 `Java` 堆大小的限制，但是它会受到本机总内存大小以及处理器寻址空间的限制。

## OOM异常

当我们遇到 `OutOfMemoryError` 异常时要能够快速定位并解决问题。

- 能够根据异常的信息快速判断是哪个区域的内存溢出。
- 知道什么样的代码可能会导致这些区域内存溢出。
- 出现这些异常后该如何处理。

### 虚拟机栈

- `StackOverflowError`：线程请求的栈深度大于虚拟机所允许的深度时抛出该异常。
- `OutOfMemoryError`：虚拟机栈扩展时无法申请到足够的内存时抛出该异常。
- 配置：单个线程的栈容量由 `-Xss` 参数设置。
- 解决：
  - 一般情况下都是因为方法内存在递归调用，而循环终止条件判断错误导致无限次的递归调用。
  - 如果是建立过多线程导致的内存溢出，在不能减少线程数量或者更换64位虚拟机的情况下，就只能通过减少最大堆和减少栈容量来换取更多的线程。

### `Java` 堆

- `OutOfMemoryError`：如果堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出该异常。一般都会有这样的错误信息：==Java heap space==。

- 场景：只要不断地创建对象，且保证 `GC Roots` 到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象数量到达最大堆的容量限制后就会产生 `OutOfMemoryError` 异常。
- 配置：
  - `-Xms` 和 `-Xmx` 参数来设置堆的最小值和最大值。
  - `-XX:+HeapDumpOnOutOfMemoryError`：通过参数该参数可以让虚拟机在出现内存溢出异常时 `Dump` 出当前的内存堆转储快照以便事后进行分析。

- 解决：需要区分==内存泄漏 和 内存溢出==。
  - 内存泄漏：肯定需要修复。
  - 内存溢出：需要判断内存中的对象是否都必须存活着，如果是则只能通过设置增加对的最大值；如果不是则可以修改代码，及时释放不必要的对象。

### 方法区

- `OutOfMemoryError`：当方法区无法满足内存分配需求时，将抛出 `OutOfMemoryError` 异常。方法区运行时常量池溢出时会有这样的错误信息：==PermGen space==。
- 场景：在经常动态生成大量 `Class` 的应用中，需要特别注意类的回收状况。
  - 使用了 `CGLib` 字节码增强和动态语言。
  - 大量 `JSP` 或动态产生 `JSP` 文件的应用。
  - 基于 `OSGi` 的应用。
- 配置：`-XX:PermSize` 和 `-XX:MaxPermSize` 限制方法区大小。

### 直接内存

- `OutOfMemoryError`：当各个内存区域总和大于屋里内存限制（或操作系统级的限制）时抛出该异常。
  - 明显的特征：当出现 `OOM` 时，`Heap Dump` 文件中不会看见明显的异常。
- 场景：大量使用 `NIO` 提供的类来直接分配内存。
- 配置：可以通过 `-XX:MaxDirectMemorySize` 来设置 `DirectMemory` 的容量，如果不指定则默认与 `Java` 堆最大值（`-Xmx` 指定）一样。