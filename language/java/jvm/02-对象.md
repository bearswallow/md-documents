# 对象的创建过程

虚拟机遇到一条 `new` 指令时，会去创建一个对象，创建流程如下：

- 首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，则必须先执行相应的类加载过程。
- 为新生对象分配内存，对象所需的内存大小在类加载完成后便可完全确定。
- 将分配到的内存空间都初始化为零值。
- 对对象的对象头进行必要的设置。
- 接着执行 `<init>` 方法（也就是 `Java` 类中的构造函数）。

创建流程的前4步都是在虚拟机中完成的，虚拟机会保证这4步的线程安全；第5步由用户编写的代码完成，线程安全由用户代码保证。所以是否正确的创建对象（对象已完全初始化）主要取决于用户代码中的构造函数。

# 内存分配方式

内存分配方式主要取决于 `Java` 堆是否规整进行选择，是否规整取决于虚拟机的垃圾收集器是否带有压缩整理功能决定。

- 指针碰撞：`Java` 堆中内存是绝对规整的，所有已分配的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，分配内存时仅仅把这个指针向空闲内存那边挪动一段与对象大小相等的距离即可。
- 空闲列表：虚拟机维护一个空闲列表，记录所有可用内存块，分配内存时从空闲列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。

在并发情况下，上述的两种内存分配都不是线程安全的，有两种方案解决线程安全问题。

- 同步处理：虚拟机采用 `CAS` 配上失败重试的方式保证更新操作的原子性。
- 本地线程分配缓冲（`TLAB`）：每个线程在 `Java` 堆中预先分配一小块内存，在线程创建对象时都从 `TLAB` 中分配，就不存在线程安全问题了，只有在 `TLAB` 用完并分配新的 `TLAB` 时才需要同步处理。
  - 可以通过 `-XX:+/-UseTLAB` 参数来设定。

# 对象的内存布局

对象在内存中存储的布局可以分为3块区域：对象头（`Header`）、实例数据（`Instance Data`）和对齐填充（`Padding`）。

- 对象头
  - 对象自身的运行时数据：哈希码（`HashCode`）、`GC` 分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。考虑到虚拟机的空间效率，这部分数据被设计成一个非固定的数据结构。
  - 类型指针：对象指向它的类元数据的指针。
  - 数据长度：只有对象是一个 `Java` 数组时才存在。
- 实例数据：字段内容分配策略
  - 相同宽度的字段总是被分配到一起。
  - 父类中定义的变量会出现在子类之前。
- 对齐填充：该部分不一定存在，由于虚拟机（`Sun HotSpot VM`）的自动内存管理系统要求对象起始地址必须是8字节的整数倍，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。

# 对象的访问定位

- 句柄访问

  ![句柄访问](E:\git-local\own\md-documents\language\java\jvm\assets\句柄访问.png)

  **优点**

  - `reference` 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 `reference` 本身不需要修改。

- 直接指针

  ![直接指针访问](E:\git-local\own\md-documents\language\java\jvm\assets\直接指针访问.png)

  **优点**

  - 访问速度快，它节省了一次指针定位的时间开销。