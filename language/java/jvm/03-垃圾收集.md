# 堆内对象回收

## 对象是否可回收判定

目前主要有两种判定方法：引用计数算法、可达性分析算法。

- 引用计数算法
  - 实现简单，判定效率也很高。
  - 很难解决对象之间相互循环引用的问题。

- 可达性分析算法
  - 通过一系列的称为 `GC Roots` 的对象作为起始点，从这些节点开始向下搜索，当一个对象到 `GC Roots` 没有任何引用链相连时，则证明此对象是不可用的。
  - 可以使用一个有向图来表示对象之间的引用，通过 `GC Roots` 节点深度优先遍历有向图，即可得到不可达的节点。
  - `GC Roots` 的对象主要包括下面几种
    - 虚拟机栈（栈帧中的本地变量表）中引用的对象。
    - 方法区中类静态属性引用的对象。
    - 方法区中常量引用到的对象。
    - 本地方法栈中 `JNI` （即一般说的 `Native` 方法）引用的对象。
  - 它可以解决对象之间相互循环引用的问题。

## 对象引用类型

根据引用对对象的垃圾回收的影响，将引用分为下列4种，这4种引用强度一次逐渐减弱。

- **强引用**

  - 在程序代码之中普遍存在的。

    ```java
    Object obj = new Object();
    ```

  - 只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。

- **软引用（`SoftReference`）**

  - 用来描述一些还有用但并非必需的对象。
  - 在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。

- **弱引用（`WeakReference`）**

  - 用来描述非必需对象。
  - 只能生存到下一次垃圾收集发生之前。

- **虚引用（`PhantomReference`）**

  - 它是最弱的一种引用关系，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。
  - 设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。

## `finalize`

当一个对象被判定为有必要执行 `finalize()` 方法，name这个对象将会放置在一个叫做 `F-Queue` 的队列中，并在稍后由一个由虚拟机自动建立的、低优先级的 `Finalizer` 线程去执行它。

- 任何一个对象的 `finalize()` 方法都只会被系统调用一次。
- 如果一个对象在 `finalize()` 方法中执行缓慢，或者发生了死循环，将很可能导致 `F-Queue` 队列中其它对象永久处于等待，甚至导致整个内存回收系统崩溃。
- `finalize()` 能做的所有工作，使用 `try-finally` 或者其他方式都可以做得更好、更及时，所以建议大家完全可以不使用 该方法。

# 方法区回收

方法区的垃圾收集主要回收两部分内容：废弃常量和无用的类。

- 回收废弃常量与回收堆内对象非常相似。
- 判定一个类是否是“无用的类”的条件
  - 该类所有的实例都已经被回收，也就是 `Java` 堆中不存在该类的任何实例。
  - 加载该类的 `ClassLoader` 已经被回收。
  - 该类对应的 `java.lang.Class` 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

在大量使用反射、动态代理、`CGLib` 等 `ByteCode` 框架、动态生成 `JSP` 以及 `OSGi` 这类频繁自定义 `ClassLoader` 的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。

# 垃圾收集算法

## 标记 - 清除算法

最基础的收集算法，算法分为“标记”和“清除”两个阶段。它主要不足有两个：

- 效率问题：标记和清除两个过程的效率都不高。
- 空间问题：标记清除之后会产生大量不连续的内存碎片。

![标记清除法](E:\git-local\own\md-documents\language\java\jvm\assets\标记清除法.jpg)

![复制算法](E:\git-local\own\md-documents\language\java\jvm\assets\复制算法.jpg)

![标记压缩算法](E:\git-local\own\md-documents\language\java\jvm\assets\标记压缩算法.jpg)

![垃圾收集器](E:\git-local\own\md-documents\language\java\jvm\assets\垃圾收集器.jpg)

