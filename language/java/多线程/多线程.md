# 线程

进程是操作系统为独立运行的程序分配各种资源（包括内存，文件句柄以及安全证书等）的基本单位。如果需要的话，在不同的进程之间可以通过一些粗粒度的通信机制来交换数据，包括：套接字（socket）、信号处理器、共享内存、信号量以及文件等。

线程是在同一个进程中同时存在多个程序控制流，也被称为轻量级进程。目前，大多数操作系统的基本调度单位都是线程。

- 线程会共享进程范围内的资源，例如：内存句柄和文件句柄。
- 线程拥有各自的程序计数器（用于指示该线程程序的执行位置）、栈以及局部变量等。

## 多线程的优势

- 发挥多处理器的强大能力
  - 多线程程序可以同时在多个处理器上执行，如果设计正确，多线程程序可以通过提高处理器资源的利用率来提升系统吞吐率。
  - 多线程还有助于在单处理器系统上获得更高的吞吐率。特别是在程序等待某个同步I/O操作完成时。
- 建模的简单性
  - 通过使用线程，可以将复杂并且异步的工作流进一步分解为一组简单并且同步的工作流，每个工作流在一个单独的线程中运行，并在特定的同步位置进行交互。
- 异步事件的简化处理
  - 在独立的线程中使用同步I/O只会阻塞当前线程，而不会影响其它线程。所以在性能允许的情况下使用同步I/O能够保持程序的简单性，异步I/O的复杂度远高于同步I/O。
- 响应更灵敏的用户界面
  - 将界面响应和刷新与业务逻辑分离到独立的线程中执行，可以避免业务逻辑处理影响界面的响应。

## 多线程带来的风险

- 安全性问题
  - 安全性的定义：永远不发生糟糕的事情。
- 活跃性问题
  - 活跃性的定义：某件正确的事情最终会发生。
  - 下列这些都会导致活跃性问题：死锁、饥饿以及活锁。
- 性能问题：线程总会带来某种程度的运行时开销。
  - 保存和恢复执行上下文，丢失局部性，并且CPU时间将更多地花在线程调度而不是线程运行上。
  - 当线程共享数据时，必须使用同步机制，而这些机制往往会抑制某些编译器优化，使内存缓存区中的数据无效，以及增加共享内存总线的同步流量。

# 线程安全性

对象的状态是指存储在状态变量（例如实例或静态域）中的数据，也包含其他依赖对象的域。

- 共享：意味着变量可以由多个线程同时访问。
- 可变：意味着变量的值在其生命周期内可以发生变化。

要使得对象是线程安全的，可采用下列方法：

- 无状态对象。
- 将状态变量修改为不可变变量。

- 采用同步机制来协同对象可变状态的访问，即保持原子性。
  - 当对象不变性条件中涉及多个变量时，且各个变量之间并不是彼此独立，就需要在单个原子操作中更新所有相关的状态变量。

==线程安全型：当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类时线程安全的==。

## 内置锁

`Java` 提供了一种内置的锁机制来支持原子性：同步代码块。

- 内置锁只能通过使用 `synchronized` 关键字来获得。

- 内置锁是一种互斥锁。

- 内置锁是可重入锁，意味着获取锁的操作的粒度是“线程”，而不是调用。

  > 重入的一种实现方法是，为每个锁关联一个获取计数值和一个所有者线程。当计数值为0时，这个锁就是被认为是没有被任何线程持有。当线程请求一个未被持有的锁时，JVM将记下锁的持有者，并且将获取计数值置为1。如果同一个线程再次获取这个锁，计数值将递增，而当线程退出同步代码块时，计数器会相应地递减。当计数值为0时，这个锁将被释放。

它包含两个部分：

- 一个作为锁的对象引用。
- 一个作为由这个锁保护的代码块。

由两种使用方式

- 横跨整个方法体的同步代码块。
- 方法体内的局部同步代码块。

```java
@ThreadSafe
public class SynchronizedSequeue {
    
    // 下面两个是横跨整个方法体的同步代码块
    public static void synchronized getStaticWhole() {...}
    public void synchronized getInstanceWhole() {...}
    
    
    // 下面两个是方法体内的局部同步代码块
    public static void getStaticPartial() {
        ...
        synchronized (SynchronizedSequeue.class) {
            ...
        }
        ...
    }
    
    public void getInstancePartial() {
        ...
        synchronized(this) {
            ...
        }
        ...
    }
    
}
```

其中：

- `getStaticWhole`、`getStaticPartial` 方法的同步代码块的锁是 `SynchronizedSequeu.class` 对象。
- `getInstanceWhole`、`getInstancePartial` 方法的同步代码块的锁是方法调用所在对象。

==线程在进入同步代码块之前会自动获得锁，并且在退出同步代码块时自动释放锁，而无论是通过正常的控制路径退出，还是通过从代码块中抛出异常退出。== 所以不需要关心锁的获取和释放。

# 最佳实践

- 定义 `@NotThreadSafe` 、`@ThreadSafe`、`@Immutable` 等注解，为每个类打上相应的注解。

  - 可以明确告诉使用者如何在多线程环境中使用这些类。
  - 可以让维护人员持续的保证线程安全类的线程安全性。

  ```java
  @ThreadSafe
  public class Sequeue {
      @GuardedBy("this") private int value;
      
      public synchronized int getNext() {
          return value++;
      }
  }
  ```

- 在需要程序严格按编写顺序执行的情况下使用同步。

  - 编译器、硬件和运行时都可以随意安排非同步代码的执行时间和顺序。

- 编写并发应用程序时，首先使代码正确运行，然后再提高代码的速度。

  - 最好也只是当性能测试结果和应用需求告诉你必须提高性能，以及测量结果表明这种优化在实际环境中确实能带来性能提升时，才进行优化。

- 加锁约定 

  - 将所有的可变状态都封装在对象内部，并通过对象的内置锁对所有访问可变状态的代码路径进行同步，使得在该对象上不会发生并发访问。
  - 缩小加锁代码块的作用范围，应该尽量将不影响共享状态且执行时间较长的操作从加锁代码块中分离出去，否则会造成严重的性能问题。